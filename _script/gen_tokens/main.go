package main

import (
	"os"
	"strings"
	"text/template"
)

type tokenInfo struct {
	name     string
	pretty   string
	hasValue bool
}

type token struct {
	ID        int
	ConstName string

	Name     string
	Pretty   string
	HasValue bool
}

var rawTokens = []tokenInfo{
	{name: "EOF"},
	{name: "ERROR"},

	{name: "ECHO_START", pretty: "{{"},
	{name: "ECHO_END", pretty: "}}"},
	{name: "CONTROL_START", pretty: "{%"},
	{name: "CONTROL_END", pretty: "%}"},
	{name: "COMMENT", pretty: "{# ... #}", hasValue: true},
	{name: "PLUS", pretty: "+"},
	{name: "MINUS", pretty: "-"},
	{name: "STAR", pretty: "*"},
	{name: "SLASH", pretty: "/"},
	{name: "LPAREN", pretty: "("},
	{name: "RPAREN", pretty: ")"},
	{name: "TILDE", pretty: "~"},
	{name: "DOT", pretty: "."},
	{name: "EQ", pretty: "=="},
	{name: "NOT_EQ", pretty: "!="},
	{name: "LT", pretty: "<"},
	{name: "GT", pretty: ">"},
	{name: "LT_EQ", pretty: "<="},
	{name: "GT_EQ", pretty: ">="},
	{name: "ASSIGN", pretty: "="},
	{name: "PIPE", pretty: "|"},
	{name: "COMMA", pretty: ","},
	{name: "LBRACKET", pretty: "["},
	{name: "RBRACKET", pretty: "]"},
	{name: "PERCENT", pretty: "%"},

	{name: "KEYWORD_OR"},
	{name: "KEYWORD_IF"},
	{name: "KEYWORD_DO"},
	{name: "KEYWORD_AND"},
	{name: "KEYWORD_FOR"},
	{name: "KEYWORD_USE"},
	{name: "KEYWORD_SET"},
	{name: "KEYWORD_NOT"},
	{name: "KEYWORD_TRUE"},
	{name: "KEYWORD_FALSE"},
	{name: "KEYWORD_ENDIF"},
	{name: "KEYWORD_ENDFOR"},
	{name: "KEYWORD_ELSE"},
	{name: "KEYWORD_ELSEIF"},
	{name: "KEYWORD_LET"},
	{name: "KEYWORD_IN"},
	{name: "KEYWORD_NULL"},

	{name: "DOLLAR_IDENT", hasValue: true},
	{name: "IDENT", hasValue: true},
	{name: "TEXT", hasValue: true},
	{name: "INT_LIT", hasValue: true},
	{name: "FLOAT_LIT", hasValue: true},
	{name: "STRING_LIT_Q1", hasValue: true},
	{name: "STRING_LIT_Q2", hasValue: true},
}

func main() {
	var tokens []token
	for i, info := range rawTokens {
		tokens = append(tokens, token{
			ID:        i + 1,
			ConstName: info.name,
			Name:      strings.TrimPrefix(info.name, "KEYWORD_"),
			Pretty:    info.pretty,
			HasValue:  info.hasValue,
		})
	}
	templateData := map[string]interface{}{
		"Tokens": tokens,
	}
	err := outputTemplate.Execute(os.Stdout, templateData)
	if err != nil {
		panic(err)
	}
}

var outputTemplate = template.Must(template.New("").Parse(`<?php

namespace KTemplate\Compile;

// File generated by gen_tokens/main.go; DO NOT EDIT!

class TokenKind {
    public const UNSET = 0;
    {{ range $.Tokens }}
    public const {{.ConstName}} = {{.ID}};{{ if .Pretty }} // {{.Pretty}}{{ end }}
    {{- end }}

    /**
     * @param int $kind
     * @return bool
     */
    public static function hasValue($kind) {
        switch ($kind) {
        {{- range $.Tokens }}
        {{- if .HasValue }}
        case self::{{.ConstName}}:
        {{- end -}}
        {{- end }}
            return true;
        default:
            return false;
        }
    }

    /**
     * @param int $kind
     * @return string
     */
    public static function prettyName($kind) {
        switch ($kind) {
        {{- range $.Tokens }}
        {{- if .Pretty }}
        case self::{{.ConstName}}:
            return '{{.Pretty}}';
        {{- end -}}
        {{- end }}
        default:
            return strtolower(self::name($kind));
        }
    }

    /**
     * @param int $kind
     * @return string
     */
    public static function name($kind) {
        switch ($kind) {
        {{- range $.Tokens }}
        case self::{{.ConstName}}:
            return '{{.Name}}';
        {{- end }}
        default:
            return '?';
        }
    }
}
`))
